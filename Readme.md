### Если нам надо описать сущность человека, у которого есть имя, возраст, пол и так далее, то естественно мы не сможем представить сущность человека в виде числа или строки. Нам потребуется несколько строк или чисел, чтобы должным образом описать человека. В этом плане человек будет выступать как сложная комплексная структура, у которого будут отдельные свойства - возраст, рост, имя, фамилия и т.д.
### Для работы с подобными структурами в JavaScript используются объекты. Каждый объект может хранить свойства, которые описывают его состояние, и методы, которые описывают его поведение
### Для создания объекта представляет использование фигурных скобок 

```js
const user = {};
```

### После создания объекта мы можем определить в нем свойства. Чтобы определить свойство, надо после названия объекта через точку указать имя свойства и присвоить ему значение:

```js
const user = {};
user.name = "Tom";
user.age = 26;
```

### В данном случае объявляются два свойства name и age, которым присваиваются соответствующие значения. После этого мы можем использовать эти свойства, например, вывести их значения в консоли:

```js
console.log(user.name);
console.log(user.age);
```

### Также можно определить свойства при определении объекта:

```js
const user = {
  
    name: "Tom",
    age: 26
};
```

### В этом случае для присвоения значения свойству используется символ двоеточия, а после определения свойства ставится запятая (а не точка с запятой).

### Методы объекта определяют его поведение или действия, которые он производит. Методы представляют собой функции. Например, определим метод, который бы выводил имя и возраст человека:

```js
const user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){
     
    console.log(user.name);
    console.log(user.age);
};
// вызов метода
user.display();
```

### Как и в случае с функциями методы сначала определяются, а потом уже вызываются.

### Существует также альтернативный способ определения свойств и методов с помощью синтаксиса массивов:

```js
const user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function(){
     
    console.log(user.name);
    console.log(user.age);
};
// вызов метода
user["display"]();
```

### Название каждого свойства или метода заключается в кавычки и в квадратные скобки, затем им также присваивается значение. Например, user["age"] = 26

### При обращении к этим свойствам и методам можно использовать либо нотацию точки (user.name), либо обращаться так: user["name"].Также можно определить свойства и методы через синтаксис массивов напрямую при создании объекта:

```js
const user = {
    ["name"]: "Tom",
    ["age"]: 26,
    ["display"]: function(){
      
        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user["display"]();
```

### Также следует отметить, что названия свойств и методов объекта всегда представляют строки. То есть мы могли предыдущее определение объекта переписать так:

```js
const user = {
    "name": "Tom",
    "age": 26,
    "display": function(){
     
        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display()
```

### С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных пробелом:

```js
const user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function(){
     
        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
console.log(user["full name"]);
user["display info"]();
```










# Глобальный контекст и объект globalThis

## В глобальном контексте this ссылается на глобальный объект. Что такое "глобальный объект" в JavaScript? Это зависит от среды, в которой выполняется код. Так, в веб-браузере this представляет объект window - объект, который представляет окно браузера. В среде Node.js this представляет объект global. А для веб-воркеров this представляет объект self

## Например, в веб-браузере при выполнении следующего кода:

```js
console.log(this);
```

### мы получим консольный вывод вроде следующего

### Window {window: Window, self: Window, document: document, name: "", location: Location, …}

### В стандарт ES2020 было добавлено определение объекта globalThis, который позволяет ссылаться на глобальный конекст вне зависимости, в какой среде и в какой ситуации выполняется код:

```js
console.log(globalThis);
```

## Контекст функции

### В пределах функции this ссылается на внешний контекст. Для функций, определенных в глобальном контексте, - это объект globalThis. Например:

```js
function foo(){
    var bar = "local";
    console.log(this.bar);
}
 
var bar = "global";
 
foo();  // global
```

### Если бы мы не использовали бы this, то обращение шло бы к локальной переменной, определенной внутри функции.

```js
function foo(){
    var bar = "local";
    console.log(bar);
}
 
var bar = "global";
 
foo();  // local
```

### Но если бы мы использовали строгий режим (strict mode), то this в этом случае имело бы значение undefined:

```js
"use strict";
function foo(){
    var bar = "local";
    console.log(this.bar);
}
 
var bar = "global";
 
foo();  // ошибка - this - undefined
```

## Контекст объекта

### В контексте объекта, в том числе в его методах, ключевое слово this ссылается на этот же объект:

```js
const obj = {
    bar: "object",
    foo: function(){
        console.log(this.bar);
    }
}
var bar = "global";
obj.foo();  // object
```

## Динамическое определение контекста

### Код функции всегда использует в качестве this внешний контекст, в которым этот код вызывается (именно вызывается, а не определяется). Рассмотрим более сложный пример:

```js
function foo(){
    var bar = "foo_bar";
    console.log(this.bar);
}
  
const obj1 = {bar:"obj1_bar", foo: foo};
const obj2 = {bar:"obj2_bar", foo: foo};
  
var bar = "global_bar";
  
foo();  // global_bar
obj1.foo();   // obj1_bar
obj2.foo();   // obj2_bar
```

## Контекст во вложенных функциях

### Если мы вызываем функцию из другой функции, вызываемая функция также будет использовать внешний контекст:

```js
var bar = "global bar";
  
function foo(){
    var bar = "foo bar";
    function moo(){
          
        console.log(this.bar);
    }
    moo();
}
foo();  // global bar
```

